import { scrollInfo } from './track.mjs';
import { observeTimeline } from './observe.mjs';
import { supportsScrollTimeline } from './supports.mjs';

function scrollTimelineFallback({ source, container, axis = "y", }) {
    // Support legacy source argument. Deprecate later.
    if (source)
        container = source;
    // ScrollTimeline records progress as a percentage CSSUnitValue
    const currentTime = { value: 0 };
    const cancel = scrollInfo((info) => {
        currentTime.value = info[axis].progress * 100;
    }, { container, axis });
    return { currentTime, cancel };
}
const timelineCache = new Map();
function getTimeline({ source, container = document.documentElement, axis = "y", } = {}) {
    // Support legacy source argument. Deprecate later.
    if (source)
        container = source;
    if (!timelineCache.has(container)) {
        timelineCache.set(container, {});
    }
    const elementCache = timelineCache.get(container);
    if (!elementCache[axis]) {
        elementCache[axis] = supportsScrollTimeline()
            ? new ScrollTimeline({ source: container, axis })
            : scrollTimelineFallback({ source: container, axis });
    }
    return elementCache[axis];
}
function isOnScrollWithInfo(onScroll) {
    return onScroll.length === 2;
}
function needsMainThreadScrollTracking(options) {
    return options && (options.target || options.offset);
}
function scroll(onScroll, options) {
    const axis = (options === null || options === void 0 ? void 0 : options.axis) || "y";
    if (typeof onScroll === "function") {
        /**
         * If the onScroll function has two arguments, it's expecting
         * more specific information about the scroll from scrollInfo.
         */
        if (isOnScrollWithInfo(onScroll) ||
            needsMainThreadScrollTracking(options)) {
            return scrollInfo((info) => {
                onScroll(info[axis].progress, info);
            }, options);
        }
        else {
            return observeTimeline(onScroll, getTimeline(options));
        }
    }
    else {
        /**
         * If we need main thread scroll tracking because we're tracking
         * a target or defined offsets, we need to create a scrollInfo timeline.
         * Over time the number of sitauations where this is true
         */
        if (needsMainThreadScrollTracking(options)) {
            onScroll.pause();
            return scrollInfo((info) => {
                onScroll.time = onScroll.duration * info[axis].progress;
            }, options);
        }
        else {
            return onScroll.attachTimeline(getTimeline(options));
        }
    }
}

export { scroll };
